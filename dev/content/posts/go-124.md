---
#################################
# Don't touch these settings.
date: '2024-12-15T15:56:29-05:00'
sidebar:
    exclude: true
type: post
#################################
# Update the title
title: "Golang 1.24 is looking seriously awesome"
# subtitle: "How Misimplementation of `PublicKeyCallback` leads to authorization bypass in Go's `x/crypto/ssh`."

# Replace if you have a good image. 
# Images are not used (yet) on individual pages, only on lists of articles.
image: /images/gopher.jpg

# Define this value if listing an external blog post not written within this site.
#link: "https://upsun.com/blog/blackfire-infrastructure-processes/"

# Update author with one or more
#   -> content/community/engage/people/AUTHOR.md
#   -> https://github.com/AUTHOR
#   -> AUTHORFirst AUTHORLast
author:
  - damz

# Choose ONE of the options below:
categories:
#   - compare
#   - core-concepts
#   - how-it-works
  - featured
  - discussions
#   - experiments
  # - how-tos
#   - releases
#   - transcripts
#   - tutorials
#   - use-cases

# Tags don't do anything yet, so ignore for now.
tags:
  - golang
#   - open-source
#   - events
#   - integrations
math: true
# toc: false
# sidebar:
#     hide: true
---

The Golang team just released the [first release candidate of Golang 1.24](https://tip.golang.org/doc/go1.24). At Upsun, we use Golang extensively for everything in our hot path, especially for the routing of HTTP requests throughout our infrastructure. Here is what we are looking forward to the most.

### Some nice performance improvements

We have not looked into these very closely yet, but they seem nice:

* 2-3% performance improvement across the board, driven by "a new builtin map implementation based on Swiss Tables, more efficient memory allocation of small objects, and a new runtime-internal mutex implementation"[^1]; and
* Two new cgo directives (`noescape` and `nocallback`)[^2] that have the potential to reduce the overhead of calling C code from Go in some cases

[^1]: _Runtime_, [Go 1.24 Release Notes](https://tip.golang.org/doc/go1.24#runtime). 
[^2]: _Tools, Cgo_; [Go 1.24 Release Notes](https://tip.golang.org/doc/go1.24#cgo).

### A weak pointer implementation (finally!)

Probably my favorite, Go 1.24 includes an implementation of a weak pointer.

A weak pointer is a reference to an object that does not prevent the garbage collector from collecting it. In practice, the implementation is simply a `weak.Pointer[T]` (which nicely mirrors `atomic.Pointer[T]`), which has a `Value() *T` method.

This new weak pointer concept -- in addition to the `unique` package [introduced in Go 1.23](https://go.dev/blog/unique) -- has the potential of powering nice improvement of memory usage in real-world Go applications.

### Post-quantum cryptography

This release introduces support for post-quantum cryptography in the `crypto/tls` package. The standard library now includes ML-KEM, "a post-quantum key exchange mechanism formerly known as Kyber and specified in [FIPS 203](https://doi.org/10.6028/NIST.FIPS.203)" [^3].

Post-quantum cryptography, if you haven't been following, is a reference to a new set of cryptographic algorithms that are deemed resistant to attacks by quantum computers, which could potentially break many of the current commonly used cryptographic algorithms.

[^3]: _New crypto/mlkem package_; [Go 1.24 Release Notes](https://tip.golang.org/doc/go1.24#crypto-mlkem).

### Encrypted Client Hello (ECH) in `crypto/tls`

The goal of Encrypted Client Hello (ECH), and of its predecessor Encrypted SNI (ESNI) is to bring a long standing privacy gap in TLS: while the actual communication over TLS is private, the identity of the server isn't. The protocol uses a public key, distributed via DNS and obtained using DNS-over-HTTPS, for encryption during the client's first flight.

This is an option we are going to look into offering on Platform.sh and Upsun at one point. We still need to figure out how to best do that.

### `encoding/json` gets better support for zero value through the new `omitzero` tag

This release fixes a long-standing issue in `encoding/json`: the `omitempty` tag only supports a subset of types, and has a definition that is at odd with the standard definition of the zero value in the language. The new `omitzero` tag now allows you to specify that a field should be omitted from the serialization if it has the zero value for its type.

The current `omitempty` option specifies that the field should be omitted from the encoding _"if the field has an empty value, defined as `false`, `0`, a `nil` pointer, a `nil` interface value, and any empty array, slice, map, or string"_. This has always been unfortunate, because Golang has different definition of what a ["zero value"](https://go.dev/ref/spec#The_zero_value) is: _"`false` for booleans, `0` for numeric types, `""` for strings, and `nil` for pointers, functions, interfaces, slices, channels, and maps"_.

If you compare the two definitions, you would note they are identical for booleans, all numeric types, empty arrays and interface values. But they handle slices and maps differently:

 * `omitempty` will omit any empty slices or maps (i.e. slices or maps that satisfy `len(S) == 0`), which includes slices or maps that are `nil`
 * `omitzero` on the other hand will only omit slices or maps that are `nil`

They also handle non-pointer struct values differently. Take [this example](https://go.dev/play/p/UWVF3QAlAS0?v=gotip):

```golang {fileName="omitzero-example.go"}
package main

import (
	"encoding/json"
	"log"
)

type Foo struct {
	OmitEmpty Bar `json:"omitempty,omitempty"`
	OmitZero  Bar `json:"omitzero,omitzero"`
}

type Bar struct {
	A int `json:"a"`
}

func main() {
	data, _ := json.Marshal(&Foo{})
	log.Printf("Generates: %s", string(data))
}
```

It generates:

```json
{"omitempty": {"a": 0}}
```

Given the above, our recommendation would be to continue using `omitempty` for maps and slices, but use `omitzero` for everything else.


### A new `tool` directive in `go.mod`

This release adds a new `tool` directive to `go.mod`, allowing you to specify dependencies to build tools without having to resort to the current convention of having an empty `tools.go` somewhere in your project.

Previously, a project depending on the `stringer` tool to generate string versions of enums would have somewhere a file containing something like:

```golang
//go:build ignore

package foo

import (
	_ "golang.org/x/tools/cmd/stringer"
)
```

And you would execute that tool with a `go:generate` line like this:

```
//go:generate go run golang.org/x/tools/cmd/stringer -type Foo
```

It worked well enough. But now in Golang 1.24, you can simply add a `tool` directive to your `go.mod`, like this:

```
tool golang.org/x/tools/cmd/stringer
```

This tool becomes available by just running:

```
//go:generate go tool stringer -type Foo
```

Not a huge deal, but still a nice quality of life improvement.


### Context support in the `testing` package

I have been wanting this for a while. The `*testing.T` and `*testing.B` types now have a `Context() context.Context` method, returning a context that is canceled just before `Cleanup` functions are called.

This will allow replacing:

```golang
func TestFoo(t *testing.T) {
    ctx, cancelFn := context.WithCancel(context.Background())
    t.Cleanup(cancelFn)

    // [...]
}
```

with:

```golang
func TestFoo(t *testing.T) {
    ctx := t.Context()

    // [...]
}
```

Another nice quality of life improvement, and the potential to make it easier and more natural to build cleaner tests.


### A new `testing/synctest` package for testing concurrent code

This is still experimental, but looks really fun. It is a new package that allows you to define "bubbles" of goroutines into which a fake clock is provided (i.e. `time.Now()` returns something different). This will eventually make it easier to test time-sensitive concurrent code, where the best practice right now is to provide a clock function returning the current time (i.e. a `func() time.Time`), so that fake time can be injected during tests (it is, for example, how the `github.com/juju/ratelimit` token-bucket implementation [is tested](https://github.com/juju/ratelimit/blob/v1.0.2/ratelimit.go#L45)).


### A lot of other things

The Golang team really gave us a nice present this holiday season. There is so much more to mention:

* An improved finalizer support with `runtime.AddCleanup`;
* The new `encoding.TextAppender` and `encoding.BinaryAppender` interfaces, and their support on many types throughout the standard library;
* Cryptographically secure random text strings with the new `rand.Text` function;
* ... and so much more.


Read the [full draft release notes](https://tip.golang.org/doc/go1.24), and don't hesitate to come and discuss your favorite parts with us [on Discord](/community/engage/discord/)!

<!-- 
## Overview

On September 5th 2024, the engineering team at Platform.sh discovered a security vulnerability in the `golang.org/x/crypto/ssh` package. Upon investigating an unexpected `Panic: runtime error: invalid memory address or nil pointer dereference` message in our edge proxy, the engineers discovered our own misimplementation and common misuse of the `PublicKeyCallback` function. We quickly remediated and found no reason to believe this vulnerability was exploited before we patched. 

Systems that implement this callback function incorrectly, end up with a vulnerability that allows an authorization bypass in Go's `x/crypto/ssh`. Our analysis suggests that this issue is prevalent across multiple projects utilizing this (`golang.org/x/crypto/ssh`) package, leading to potentially severe security implications. 

At the time of writing there are [~19k known importers of this ssh package](https://pkg.go.dev/golang.org/x/crypto/ssh?tab=importedby).

While this is ultimately a bug in the usage of the package by end-users, we believe that the design of the `PublicKeyCallback` function and its documentation is contributing to the vulnerability, which has the potential to affect a broad spectrum of users in the wild. Given the broad impact potential we chose to disclose the vulnerability to the Go Security team. 

## Timeline

- **September 5th, 2024**: Engineering discovered security auth bypass in `x/crypto/ssh`.
- **September 12th 2024**: Reported findings to Go Security team and implemented mitigations.
- **October 2nd, 2024**: Go security team reviewed our report and confirmed our findings.
- **December 6, 2024**: [Go security team made pre-announcement](https://groups.google.com/g/golang-announce/c/ZA1tNV10Mcs).
- **December 11, 2024**: Go security team made [public](https://groups.google.com/g/golang-announce/c/-nPEi39gI4Q) [disclosure](https://github.com/golang/go/issues/70779) and released [v0.31.0](https://pkg.go.dev/golang.org/x/crypto@v0.31.0/ssh) of `golang.org/x/crypto`. 

## Context

The SSH-2 protocol, specified in [RFC 4253](https://datatracker.ietf.org/doc/html/rfc4253), was designed in its current form back in 2006 as an evolution of the original SSH-1 protocol going back to 1995. Back in SSH-1 times, the client authentication was done as a challenge/response protocol outlined under `SSH_AUTH_RSA` on pages 11-12 [here](https://www.ietf.org/archive/id/draft-ylonen-ssh-protocol-00.txt). This allowed clients to ask the server where a particular key had the potential to be accepted:

> "The client sends `SSH_CMSG_AUTH_RSA` with public key modulus (n) as an argument. **The server may respond immediately with `SSH_SMSG_FAILURE` if it does not permit authentication with this key.** Otherwise it generates a challenge." [^1]

The SSH-2 protocol changed this to a static signature based on data that is already known by the two parties, but kept a query mechanism in place as a way to improve performance and usability. [Section-7 of RFC 4252](https://datatracker.ietf.org/doc/html/rfc4252#section-7):

> "Private keys are often stored in an encrypted form at the client host, and the user must supply a passphrase before the signature can be generated. Even if they are not, the signing operation involves some expensive computation. **To avoid unnecessary processing and user interaction, the following message is provided for querying whether authentication using the "publickey" method would be acceptable.**" [^2]

## Details

The `golang.org/x/crypto/ssh` package is an implementation of the SSH-2 protocol. The golang implementation hides the complexity of the "query that a key might be accepted / actually authenticate" dance under a single API.

`PublicKeyCallback` is called only once for a particular key, before the client has proven possession of the private key, via a cache implemented in `server.go#L621`.
The comments in `PublicKeyCallBack` function below have critical implementation details that are easily overlooked.

```go {filename="server.go"}
// PublicKeyCallback, if non-nil, is called when a client
// offers a public key for authentication. It must return a nil error
// if the given public key can be used to authenticate the
// given user. For example, see CertChecker.Authenticate. A
// call to this function does not guarantee that the key
// offered is in fact used to authenticate. To record any data
// depending on the public key, store it inside a
// Permissions.Extensions entry.
PublicKeyCallback func(conn ConnMetadata, key PublicKey) (*Permissions, error)
```

The ease of misimplementation for this function was previously mentioned in issue [#20094 from April 2017](https://github.com/golang/go/issues/20094), and clarifying code comments were [subsequently added](https://go-review.googlesource.com/c/crypto/+/45311/7/ssh/server.go#69).

Despite the description hinting that `PublicKeyCallBack` func needs to be implemented in a stateless way, what can happen, if the func is stateful, is a client can successfully query a public key that it doesn't use. Where doing so only requires knowledge of the public key which, by nature of being public, is very know-able. For example, the public keys of all github users are public if you append `.keys` to the user url. 

{{% callout type="blue" %}}
[Here are Damien Tournoud's (our CTO) public keys for your enjoyment](https://github.com/damz.keys).
{{% /callout %}}

The flaw in this process occurs because the `PublicKeyCallback` is not called again after the client presents the key, allowing the attacker to gain access without possessing the private key for the queried key.

## Relevance to Upsun & Platform.sh

Our SSH gateways allow our customers to access containers running on our infrastructure using standard SSH tools and are based on the open source `golang.org/x/crypto/ssh` package. 

We favour open source technologies and enjoy [contributing and supporting open source projects we love](https://platform.sh/community/open-source/). Catching and addressing an issue like this is something our teams take great pride in. It genuinely feels awesome when you can make the tools you use better for everyone else. 

Given the reach of this issue (19k importers) we believed the upstream Go team was best suited to handle the disclosure. We encourage others to also disclose responsibly and have confidence in their upstream maintainers. As developers ourselves we understand it can often be a thankless job, and unwarranted complications are not welcome. Eliminating unnecessary complexities for developers is the core our products are built on. 

Before this devolves too much into a “puff piece,”  if you relate with any of these sentiments please reach out!

## Our recommendations 

If you have a Go project depending on crypto/ssh, update the package to the newest version with:

```bash
go get -u golang.org/x/crypto/ssh
```

Then, if your code has a `PublicKeyCallback` method (implementing the `ssh.ServerConfig` interface), you will need to ensure that:

* The callback must be stateless, or in other words, it must not have any side effects. As the comments on the interface suggest, return any state directly in the function as part of the `ssh.Permissions` object.  
* Do not assume that the public key is authenticated at this stage. Use the `PostSuccessAuthCallback` if you need to run code after the client has proved possession of the private key. This will be passed the same `ssh.Permissions` object.

Even if the `PublicKeyCallback` is not part of your own code, remember to check that you are not using any other packages that misimplement the same callback. If so, they will also need to be updated, fixed or removed.

The package maintainers were very understanding and professional as we communicated that users of the `x/crypto/ssh` package expect that the key used by the client for authentication (if successful) matches the one passed to the most recent call to `PublicKeyCallback`. 

The maintainers' cache fix should mitigate this vulnerability for the majority of implementations, unfortunately it cannot fix all. 

[^1]: Ylonen, T. (1995) [The SSH (Secure Shell) Remote Login Protocol](https://www.ietf.org/archive/id/draft-ylonen-ssh-protocol-00.txt#:~:text=private%20host%20key.-,SSH_AUTH_RSA,-The%20idea%20behind). IETF.
[^2]: Ylonen, T. (2006) [The Secure Shell (SSH) Authentication Protocol](https://datatracker.ietf.org/doc/html/rfc4252#section-7). IETF. -->

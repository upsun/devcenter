---
#################################
# Don't touch these settings.
date: '2024-12-13T15:56:29-05:00'
sidebar:
    exclude: true
type: post
#################################
# Update the title
title: "CVE-2024-45337"
subtitle: "How Misimplementation of `PublicKeyCallback` leads to authorization bypass in Go's `x/crypto/ssh`."

# Replace if you have a good image. 
# Images are not used (yet) on individual pages, only on lists of articles.
image: /images/cve-2024-45337.webp

notice: |
  This article was originally published on the [Platform.sh blog](https://platform.sh/blog/uncovered-and-patched-golang-vunerability/).

# Define this value if listing an external blog post not written within this site.
#link: "https://upsun.com/blog/blackfire-infrastructure-processes/"

# Update author with one or more
#   -> content/community/engage/people/AUTHOR.md
#   -> https://github.com/AUTHOR
#   -> AUTHORFirst AUTHORLast
author:
  - "Vince Parker"

# Choose ONE of the options below:
categories:
#   - compare
#   - core-concepts
#   - how-it-works
  - featured
  - discussions
#   - experiments
  # - how-tos
#   - releases
#   - transcripts
#   - tutorials
#   - use-cases

# Tags don't do anything yet, so ignore for now.
tags:
  - security
  - open-source
#   - events
#   - integrations
math: true
---

{{% callout %}}
This article was originally published on the [Platform.sh blog](https://platform.sh/blog/uncovered-and-patched-golang-vunerability/).
{{% /callout %}}

## Overview

On September 5th 2024, the engineering team at Platform.sh discovered a security vulnerability in the `golang.org/x/crypto/ssh` package. Upon investigating an unexpected `Panic: runtime error: invalid memory address or nil pointer dereference` message in our edge proxy, the engineers discovered our own misimplementation and common misuse of the `PublicKeyCallback` function. We quickly remediated and found no reason to believe this vulnerability was exploited before we patched. 

Systems that implement this callback function incorrectly, end up with a vulnerability that allows an authorization bypass in Go's `x/crypto/ssh`. Our analysis suggests that this issue is prevalent across multiple projects utilizing this (`golang.org/x/crypto/ssh`) package, leading to potentially severe security implications. 

At the time of writing there are [~19k known importers of this ssh package](https://pkg.go.dev/golang.org/x/crypto/ssh?tab=importedby).

While this is ultimately a bug in the usage of the package by end-users, we believe that the design of the `PublicKeyCallback` function and its documentation is contributing to the vulnerability, which has the potential to affect a broad spectrum of users in the wild. Given the broad impact potential we chose to disclose the vulnerability to the Go Security team. 

## Timeline

- **September 5th, 2024**: Engineering discovered security auth bypass in `x/crypto/ssh`.
- **September 12th 2024**: Reported findings to Go Security team and implemented mitigations.
- **October 2nd, 2024**: Go security team reviewed our report and confirmed our findings.
- **December 6, 2024**: [Go security team made pre-announcement](https://groups.google.com/g/golang-announce/c/ZA1tNV10Mcs).
- **December 11, 2024**: Go security team made [public](https://groups.google.com/g/golang-announce/c/-nPEi39gI4Q) [disclosure](https://github.com/golang/go/issues/70779) and released [v0.31.0](https://pkg.go.dev/golang.org/x/crypto@v0.31.0/ssh) of `golang.org/x/crypto`. 

## Context

The SSH-2 protocol, specified in [RFC 4253](https://datatracker.ietf.org/doc/html/rfc4253), was designed in its current form back in 2006 as an evolution of the original SSH-1 protocol going back to 1995. Back in SSH-1 times, the client authentication was done as a challenge/response protocol outlined under `SSH_AUTH_RSA` on pages 11-12 [here](https://www.ietf.org/archive/id/draft-ylonen-ssh-protocol-00.txt). This allowed clients to ask the server where a particular key had the potential to be accepted:

> "The client sends `SSH_CMSG_AUTH_RSA` with public key modulus (n) as an argument. **The server may respond immediately with `SSH_SMSG_FAILURE` if it does not permit authentication with this key.** Otherwise it generates a challenge." [^1]

The SSH-2 protocol changed this to a static signature based on data that is already known by the two parties, but kept a query mechanism in place as a way to improve performance and usability. [Section-7 of RFC 4252](https://datatracker.ietf.org/doc/html/rfc4252#section-7):

> "Private keys are often stored in an encrypted form at the client host, and the user must supply a passphrase before the signature can be generated. Even if they are not, the signing operation involves some expensive computation. **To avoid unnecessary processing and user interaction, the following message is provided for querying whether authentication using the "publickey" method would be acceptable.**" [^2]

## Details

The `golang.org/x/crypto/ssh` package is an implementation of the SSH-2 protocol. The golang implementation hides the complexity of the "query that a key might be accepted / actually authenticate" dance under a single API.

`PublicKeyCallback` is called only once for a particular key, before the client has proven possession of the private key, via a cache implemented in `server.go#L621`.
The comments in `PublicKeyCallBack` function below have critical implementation details that are easily overlooked.

```go {filename="server.go"}
// PublicKeyCallback, if non-nil, is called when a client
// offers a public key for authentication. It must return a nil error
// if the given public key can be used to authenticate the
// given user. For example, see CertChecker.Authenticate. A
// call to this function does not guarantee that the key
// offered is in fact used to authenticate. To record any data
// depending on the public key, store it inside a
// Permissions.Extensions entry.
PublicKeyCallback func(conn ConnMetadata, key PublicKey) (*Permissions, error)
```

The ease of misimplementation for this function was previously mentioned in issue [#20094 from April 2017](https://github.com/golang/go/issues/20094), and clarifying code comments were [subsequently added](https://go-review.googlesource.com/c/crypto/+/45311/7/ssh/server.go#69).

Despite the description hinting that `PublicKeyCallBack` func needs to be implemented in a stateless way, what can happen, if the func is stateful, is a client can successfully query a public key that it doesn't use. Where doing so only requires knowledge of the public key which, by nature of being public, is very know-able. For example, the public keys of all github users are public if you append `.keys` to the user url. 

{{% callout type="blue" %}}
[Here are Damien Tournoud's (our CTO) public keys for your enjoyment](https://github.com/damz.keys).
{{% /callout %}}

The flaw in this process occurs because the `PublicKeyCallback` is not called again after the client presents the key, allowing the attacker to gain access without possessing the private key for the queried key.

## Relevance to Upsun & Platform.sh

Our SSH gateways allow our customers to access containers running on our infrastructure using standard SSH tools and are based on the open source `golang.org/x/crypto/ssh` package. 

We favour open source technologies and enjoy [contributing and supporting open source projects we love](https://platform.sh/community/open-source/). Catching and addressing an issue like this is something our teams take great pride in. It genuinely feels awesome when you can make the tools you use better for everyone else. 

Given the reach of this issue (19k importers) we believed the upstream Go team was best suited to handle the disclosure. We encourage others to also disclose responsibly and have confidence in their upstream maintainers. As developers ourselves we understand it can often be a thankless job, and unwarranted complications are not welcome. Eliminating unnecessary complexities for developers is the core our products are built on. 

Before this devolves too much into a “puff piece,”  if you relate with any of these sentiments please reach out!

## Our recommendations 

If you have a Go project depending on crypto/ssh, update the package to the newest version with:

```bash
go get -u golang.org/x/crypto/ssh
```

Then, if your code has a `PublicKeyCallback` method (implementing the `ssh.ServerConfig` interface), you will need to ensure that:

* The callback must be stateless, or in other words, it must not have any side effects. As the comments on the interface suggest, return any state directly in the function as part of the `ssh.Permissions` object.  
* Do not assume that the public key is authenticated at this stage. Use the `PostSuccessAuthCallback` if you need to run code after the client has proved possession of the private key. This will be passed the same `ssh.Permissions` object.

Even if the `PublicKeyCallback` is not part of your own code, remember to check that you are not using any other packages that misimplement the same callback. If so, they will also need to be updated, fixed or removed.

The package maintainers were very understanding and professional as we communicated that users of the `x/crypto/ssh` package expect that the key used by the client for authentication (if successful) matches the one passed to the most recent call to `PublicKeyCallback`. 

The maintainers' cache fix should mitigate this vulnerability for the majority of implementations, unfortunately it cannot fix all. 

[^1]: Ylonen, T. (1995) [The SSH (Secure Shell) Remote Login Protocol](https://www.ietf.org/archive/id/draft-ylonen-ssh-protocol-00.txt#:~:text=private%20host%20key.-,SSH_AUTH_RSA,-The%20idea%20behind). IETF.
[^2]: Ylonen, T. (2006) [The Secure Shell (SSH) Authentication Protocol](https://datatracker.ietf.org/doc/html/rfc4252#section-7). IETF.
